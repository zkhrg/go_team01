# Team 01 - Go Boot camp

## Warehouse 13

## Contents

1. [Глава I](#chapter-i) \
    1.1. [Общие правила](#general-rules)
2. [Глава II](#chapter-ii) \
    2.1. [Правила дня](#rules-of-the-day)
3. [Глава III](#chapter-iii) \
    3.1. [Intro](#intro)
4. [Глава IV](#chapter-iv) \
    4.1. [Задача 00: Масштабируемость](#exercise-00-scalability)
5. [Глава V](#chapter-v) \
    5.1. [Задача 01: Балансировка и запросы](#exercise-01-anomaly-balancing-and-queries)
6. [Глава VI](#chapter-vi) \
    6.1. [Задача 02: Да здравствует король](#exercise-02-long-live-the-king)
7. [Глава VII](#chapter-vii) \
    7.1. [Задача 03: Достижение консенсуса](#exercise-03-consensus)
8. [Глава VIII](#chapter-viii) \
    8.1. [Список литературы](#reading)

<h2 id="chapter-i" >Глава I</h2>
<h2 id="general-rules" >Общие правила</h2>

- Ваши программы не должны неожиданно завершать работу (выдавая ошибку при вводе корректных данных). Если это произойдет, ваш проект будет признан нефункциональным и получит 0 баллов во время оценки.
- Мы рекомендуем вам создать тестовые программы для вашего проекта, даже если эту работу не нужно будет представлять на конкурс и она не будет оцениваться. Это даст вам возможность легко протестировать свою работу и работы ваших коллег. Вы найдете эти тесты особенно полезными во время защиты. Действительно, во время защиты вы можете свободно использовать свои тесты и/или тесты коллег, которых вы оцениваете.
- Отправьте свою работу в назначенный вам репозиторий git. Оцениваться будут только работы из репозитория git.
- Если ваш код использует внешние зависимости, он должен использовать [Go Modules](https://go.dev/blog/using-go-modules) для управления ими

<h2 id="chapter-ii" >Глава II</h2>
<h2 id="правила дня" >Правила дня</h2>

- Вы должны включать только файлы `.go` и (в случае внешних зависимостей) `go.mod` + `go.sum`
- Ваш код для этой задачи должен быть собран с помощью простого `go build`
- Все ваши тесты должны быть доступны для запуска при вызове стандартного `go test ./...`

<h2 id="chapter-iii" >Глава III</h2>
<h2 id="intro" >Введение</h2>

&mdash; Да ладно, Арти, это же древность! - Латтимер чуть не вцепился себе в волосы.- На дворе 21 век, никто больше не пользуется ручкой и бумагой для составления каталогов! <br>
&mdash; Что ты хочешь, чтобы я сделал, Пит? Так было всегда! <br>
&mdash; Ну, у нас ведь есть компьютер, не так ли? Он довольно древний, но мы можем установить... <br>
&mdash; Нет, мы не можем! Вы ведь знаете, что хранилище должно оставаться совершенно секретным, не так ли? Мы не загружаем и не устанавливаем здесь никакого программного обеспечения. <br>
&mdash; Хорошо, значит, вы хотите, чтобы мы написали собственную реализацию базы данных? Это сработает? <br>
&mdash; Хм, возможно, это сработает... <br>
&mdash; Отлично! Итак, я попрошу Майка реализовать это для нас! <br>
&mdash; Подождите, я думал, вы говорили о том, чтобы реализовать это самостоятельно... <br>
&mdash; Нет, я не силен в программировании. В любом случае, давайте разработаем это! Какую информацию мы должны хранить? <br>
&mdash; Каждому артефакту присваивается его собственный уникальный идентификатор, и затем мы должны сохранить некоторые метаданные о нем в структурированном формате. Кроме того, все должно быть доступно через интерфейс командной строки, поскольку я не понимаю эти современные графические интерфейсы... <br>

Час спустя...

&mdash; Что? Вы хотите, чтобы я написал полнофункциональное хранилище значений ключей для работы с документами в формате JSON? С нуля? <br>
&mdash; Я знаю, я знаю! Но вы не одиноки! Вот, я приготовила вам кофе в кофейной кружке Энди Уорхола, так что это практически неограниченный источник кофеиновой суперсилы. <br>
&mdash; Но, Пит! Нам нужно решить множество проблем! Что, если данные повреждены? Что, если мы не сможем получить доступ к некоторым артефактным данным, когда они нам больше всего понадобятся? <br>
&mdash; Не волнуйся, Майка, ты сможешь это сделать! Я тоже буду сидеть здесь и помогать. Давай просто рассмотрим проблемы одну за другой. <br>

<h2 id="глава-iv" >Глава IV</h2>
<h3 id="ex00">Задача 00: Масштабируемость</h3>

Через некоторое время классная доска была покрыта надписями.<br>
* "Доступ через командную строку - должно быть отдельное приложение, которое будет предоставлять `REPL` и подключаться к запущенному экземпляру по сети, даже если это всего лишь локальный хост и порт".
* "Мы должны иметь возможность отключить любой экземпляр (процесс) базы данных, и он должен продолжать работать и предоставлять ответы на запросы. Это означает, что одним из настраиваемых параметров, например, должен быть коэффициент репликации, означающий, сколько копий одного и того же документа мы храним. Для целей тестирования, вероятно, достаточно 2"
"Клиент должен выполнить повторную проверку, доступен ли текущий экземпляр базы данных. Если он перестает отвечать на запросы, он должен автоматически переключиться на другой экземпляр" 
* "Кроме того, для простоты давайте предположим, что масштабируемость означает, что клиент должен быть осведомлен обо всех других узлах. Каждый ответ от текущего узла должен содержать адреса и порты всех известных на данный момент экземпляров, а также текущий коэффициент репликации".
* Итак, здесь нам нужно реализовать две программы - одну как клиентскую, а другую как экземпляр базы данных. Всякий раз, когда вы запускаете новый экземпляр, вы должны иметь возможность указать ему на существующий экземпляр, поэтому после получения сигнала он отправит его по своему хосту и порту на все другие запущенные узлы, и все будут знать новичка. 
* Если узел экземпляра запущен с коэффициентом репликации, отличным от существующих узлов, он должен обнаружить это и автоматически завершить работу без присоединения к кластеру. Это означает, что коэффициент репликации, вероятно, также должен быть включен в `heartbeat`.
* Для этого вы можете использовать любой сетевой протокол, который вам нравится - `HTTP`, `gRPC` и т.д.
* Всякий раз, когда коэффициент репликации превышает количество запущенных узлов, информация об этой проблеме должна быть немедленно включена и отображаться в каждом подключенном клиенте в явном виде. Вы можете увидеть пример сеанса пользователя в задаче 01.

Собственно работа с документами будет реализована в следующем задании. <br>

<h2 id="глава-v" >Глава V</h2>
<h3 id="ex01">Задача 01: Балансировка и запросы</h3>

Хорошо, давайте использовать строки `UUID4` в качестве ключей артефакта. Нам также нужно реализовать некоторую балансировку для обеспечения отказоустойчивости...<br>
Наша простая база данных должна поддерживать только три операции - `GET`, `SET` и `DELETE`. <br>
Вот как должен выглядеть типичный сеанс с комментариями (начинающимися с #): <br>

```sh
~$ ./warehouse-cli -H 127.0.0.1 -P 8765
```
```txt
Connected to a database of Warehouse 13 at 127.0.0.1:8765
Known nodes:
127.0.0.1:8765
127.0.0.1:9876
127.0.0.1:8697
> SET 12345 '{"name": "Chapayev's Mustache comb"}'
Error: Key is not a proper UUID4
> SET 0d5d3807-5fbf-4228-a657-5a091c4e497f '{"name": "Chapayev's Mustache comb"}'
Created (2 replicas)
> GET 0d5d3807-5fbf-4228-a657-5a091c4e497f
'{"name": "Chapayev's Mustache comb"}'
> DELETE 0d5d3807-5fbf-4228-a657-5a091c4e497f
Deleted (2 replicas)
> GET 0d5d3807-5fbf-4228-a657-5a091c4e497f
Not found
>
# if current instance is stopped in the background
Reconnected to a database of Warehouse 13 at 127.0.0.1:8697
Known nodes:
127.0.0.1:9876
127.0.0.1:8697
> 
# if another current instance is stopped in the background
Reconnected to a database of Warehouse 13 at 127.0.0.1:9876
Known nodes:
127.0.0.1:9876
WARNING: cluster size (1) is smaller than a replication factor (2)!
>
```

* Если ключ, указанный в SET, уже существует в базе данных, то его значение должно быть перезаписано. Если это не так, то операция SET должна обеспечивать согласованность чтения после записи, что означает, что немедленное чтение должно дать вам правильное значение.
* При обновлении существующего значения или его удалении должна быть реализована возможная согласованность, что означает, что немедленное (грязное) чтение может (но не "должно"!) дать вам старые результаты, но через пару секунд данные должны быть обновлены до надлежащего нового состояния.
* Вы можете реализовать балансировку на основе хэша ключей, чтобы ваш клиент мог явно рассчитать для каждой записи список узлов, где она должна храниться, в соответствии с коэффициентом репликации. Это также пригодится для удаления.
* Если текущий узел прерывается во время записи, ваш клиент должен автоматически выполнить другой запрос к другому доступному узлу. Единственный случай, когда пользователь должен увидеть ошибку типа "Не удалось записать/прочитать запись", - это когда все экземпляры не работают.

<h2 id="глава-vi" >Глава VI</h2>
<h3 id="ex02">Задача 02: Да здравствует король</h3>

Давайте улучшим логику по сравнению с заданиями 00/01. Теперь мы вводим понятия ведущего и ведомого узлов. Это подводит нас к списку важных изменений:

* отныне клиент взаимодействует ТОЛЬКО с ведущим узлом. Функция хэширования, определяющая, куда записывать реплики, теперь находится на Лидере, а не на клиенте.
 все узлы (Лидер и подписчики) продолжают отправлять друг другу сообщения с полным списком узлов. Если узел не реагирует на сердцебиение в течение определенного настраиваемого времени ожидания (для целей тестирования вы должны установить его на 10 секунд по умолчанию)
* если Ведущий остановлен, оставшиеся подписчики должны иметь возможность выбрать среди них нового Ведущего. Для простоты каждый из них может просто упорядочить список узлов по какому-либо другому уникальному идентификатору (числовой идентификатор, порт и т.д.) и выбрать самый верхний из них. С этого момента все сообщения о сердцебиении будут включать нового избранного Лидера
* если не удается подключиться к известному Лидеру, клиент должен попытаться связаться с подписчиками, чтобы получить от них сообщение о сердцебиении. Если Лидер убит, это сообщение о сердцебиении будет включать нового избранного лидера

<h2 id="глава-vii" >Глава VII</h2>
<h3 id="ex03">Задача 03: Достижение консенсуса</h3>

**ПРИМЕЧАНИЕ: это задание совершенно необязательно. Оно оценивается только как бонусная часть**

Возможно, вы заметили, что в приведенной выше схеме многое может пойти не так, в частности, условия гонки и возможность потери некоторых данных из-за того, что реплики не синхронизируются автоматически между экземплярами после того, как некоторые из них умирают.

Вы можете попробовать решить эту проблему за дополнительную плату, либо используя существующее решение, либо написав обходной путь самостоятельно. Вот несколько вариантов:

* Используя существующую реализацию Raft или написав минимальную реализацию самостоятельно
* Используя внешние инструменты, такие как Zookeeper или Etcd
* Выберите какой-нибудь другой способ, например, Paxos, какую-нибудь блокчейн-реализацию или свои собственные хаки

... Надеюсь, теперь Питу и Майке не придется рыться в куче бумаг каждый раз, когда им нужно что-то найти. Вероятно, Арти все равно это сделает, потому что иногда действительно трудно противостоять силе привычки.

Но я думаю, что это было интересное путешествие, во время которого мы нашли несколько интересных артефактов. А ты?